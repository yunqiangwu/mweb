[{"title":"什么是 wasm(webassembly) 技术","date":"2022-07-10T12:08:58.000Z","path":"2022/07/10/wasm/","text":"什么是 wasm wasi wapm 技术什么是 wasm wasm官网: https://webassembly.org/ wasm 全称 WebAssembly，是一种通用字节码的技术，通过该技术将其他语言（比如 go, rust, c&#x2F;c++, 等）的程序代码编译成可以直接在浏览器环境执行的字节码程序。因为该 WebAssembly 是一种字通用的节码技术规范，所以 WebAssembly 不仅仅可以在浏览器执行，还可以在其他变成语言环境中执行，比如 ，python， c，go， rust，等. 为什么需要搞一个 wasm 字节码，不能所以平台都用 js 做为 通用编码技术吗？理论上 在其他语言环境中实现 js 执行引擎， 是可以把 js 做为一个 通用编码技术的。那为什么还需做一个 wasm 出来呢。 我认为有以下几点原因： js 代码是文本文件格式。在 web 环境下，网络传输效率远远不如 wasm 二进制数据传输。 js 相对于 c 和 rust ，而已，是一种弱类型语言，写代码没有严格类型校验，容易写成不稳定的代码。 js 是有 GC(自动垃圾清理功能)，用户不用关注内存的处理，导致的结果就是 GC 处理过程严重拖慢性能， 而且由于是系统 GC， 用户很难精确控制内存。容易导致内存占用过高。 js 是文本解析型编程语言，文本解析效率低，wasm 二进制代码解析执行效率会高于 js。 js 由于历史原因，js 本身就存在一些缺陷（js 之父说的），而且 js 引擎需要实现的成本过高， wasm 的执行引擎可以说是 比 js 新的产物， 在设计 wasm 字节码的时候，考虑各个方便比较完善，漏洞也比较少。 什么是 wasi wasi官网: https://wasi.dev/ wasi 全称 The WebAssembly System Interface 通俗来讲就是一个对接规范。 就像前后端分离的 RestFul 类似，只要前后端约定一套 RESTful 接口对接规范 ，无论前端使用的框架是 jQuery 或 vue 或 react ， 无论后端使用 java node.js 或者 java 还是 go。 都可以进行前后端通信。 wasi 也是同样的道理， wasi 约定了也行函数接口，不同的语言代码的生成的字节码规则是一致的，这样就可以在其他平台执行这个字节码。 举个栗子： 比如我用 c语言 写了一个程序，读取某个文件， 把文件内容输出到屏幕。 然后我把这个程序编译成 wasm 字节码。 然后让 web 浏览器去执行。 我们都知道 浏览器是不可以直接读取系统文件的。那么 web 浏览器应该如何去执行这个字节码程序呢？ 通过 wasi (后文会介绍) 协议，我们可以在 浏览器环境中用 JavaScript 写 读取文件的 API 回调函数，然后在执行字节码程序之前，把这个 options 传给 wasm 执行引擎。 js 中可以实现 文件读取逻辑（可能是从网络中读取，也可以返回一段字符串）。 然后 web 浏览器 就可以无障碍的执行这段 字节码程序了。 wasm的好处: 可以移植其他平台的代码给不同平台执行（跨平台跨语言执行能力） 可以用到其他语言的特性，给浏览器执行环境赋能，比如通过 rust 生成的 wasm，有更高的执行效率和内存安全特性。 通过 wasi 可以在浏览器端实现模拟 文件系统， sock 网络服务等， 实现类似 webide 如何生成 wasm 字节码程序因为 wasm 是一种通用的字节码交互技术，大部分流行的语言的环境的 sdk 工具包中就内置了 wasm 相关的工具。 比如 go 语言中可以通 GOOS=js GOARCH=wasm go build -o static/main.wasm 生成 wasm 字节码程序。 另外还有其他第三方或者 wasm官方的工具。目前比较通用的一个工具是：wasmtime wasmtime官网文档: https://docs.wasmtime.dev/ 这里简单举个栗子 用 Rust 生成字节码。 第一步我们需要安装 Rust 语言环境： 安装 rust 文档 第二步 安装 rust 的 wasm 工具 1$ cargo install cargo-wasi 第三步 创建 rust hello 项目 12$ cargo new hello-world$ cd hello-world 修改 src&#x2F;main.rs 添加导出函数 123pub fn main() &#123; println!(&quot;Hello, world! wasm!&quot;);&#125; 调试运行 rust wasi 字节码程序 123456789$ cargo wasi runinfo: downloading component &#x27;rust-std&#x27; for &#x27;wasm32-wasi&#x27;info: installing component &#x27;rust-std&#x27; for &#x27;wasm32-wasi&#x27; Compiling hello-world v0.1.0 (/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 0.16s Running `/.cargo/bin/cargo-wasi target/wasm32-wasi/debug/hello-world.wasm` Running `target/wasm32-wasi/debug/hello-world.wasm`Hello, world! 通过 wasmtime 工具 运行 wasi 字节码程序。 需要安装 wasmtime 工具， 安装文档：https://docs.wasmtime.dev/cli-install.html 12wasmtime target/wasm32-wasi/debug/hello-world.wasmHello, world! 到此为止我们就实现生成了 wasm 字节码程序了 为什么我更推荐使用 rust 字节码程序。因为 rust 是一种强类型，性能比较优秀的的 编程语言。 和 c 语言一样没有 gc，但是 rust 在内存操作方面，rust 编译器有优秀的 语法检查机制，所以可以让用户写出优秀的内存安全代码。 而且 rust 和 c 语言相比， 由于 rust 是后辈， 所以 rust 有很多新的现代语言特性， 可以通过简单的代码语法糖，实现 c语言的需要很多代码实现的功能。 如何在 nodejs 环境执行 wasm 代码nodejs 16 内置了 WebAssembly API 在 刚刚的 rust 项目下， 创建 一个 test.js 脚本， 写入如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116(async () =&gt; &#123; try&#123; const fs = require(&#x27;fs&#x27;); const path = require(&#x27;path&#x27;); // 定义 wasm 环境变量 const env = &#123; PWD: &#x27;/&#x27; &#125;; // wasm 内存操作对象 let thisView = null; // wasm 程序接口对象 let wasmRes = null; // wasm 内存对象 let thisMemory = null; // 控制台输出信息缓存变量 let consoleLogData = &#x27;&#x27;; const refreshMemory = () =&gt; &#123; if (!thisView || thisView.buffer.byteLength === 0) &#123; thisView = new DataView(thisMemory.buffer); &#125; &#125; const getiovs = (iovs, iovsLen) =&gt; &#123; refreshMemory(); const buffers = Array.from(&#123; length: iovsLen &#125;, (_, i) =&gt; &#123; const ptr = iovs + i * 8; const buf = thisView.getUint32(ptr, true); const bufLen = thisView.getUint32(ptr + 4, true); return new Uint8Array(thisMemory.buffer, buf, bufLen); &#125;); return buffers; &#125;; function Uint8ArrayToString(fileData)&#123; var dataString = &quot;&quot;; for (var i = 0; i &lt; fileData.length; i++) &#123; dataString += String.fromCharCode(fileData[i]); &#125; return dataString &#125; const importObject = &#123; wasi_snapshot_preview1: &#123; fd_write: (fd, iovs, iovsLen, nwritten) =&gt; &#123; let written = 0; const buffers = getiovs(iovs, iovsLen); buffers.forEach(buffer =&gt; &#123; consoleLogData+= Uint8ArrayToString(buffer); written+=buffer.length; &#125;); thisView.setUint32(nwritten, written, true); return 0; &#125;, environ_get: (environ, environBuf) =&gt; &#123; refreshMemory(); let coffset = environ; let offset = environBuf; Object.entries(env).forEach(([key, value]) =&gt; &#123; thisView.setUint32(coffset, offset, true); coffset += 4; offset += Buffer.from(thisMemory.buffer).write( `$&#123;key&#125;=$&#123;value&#125;\\0`, offset ); &#125;); return 0; &#125;, environ_sizes_get: (environCount, environBufSize) =&gt; &#123; refreshMemory(); const envProcessed = Object.entries(env).map( ([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;\\0` ); const size = envProcessed.reduce( (acc, e) =&gt; acc + Buffer.byteLength(e), 0 ); thisView.setUint32(environCount, envProcessed.length, true); thisView.setUint32(environBufSize, size, true); return 0; &#125;, proc_exit: (rval) =&gt; &#123; return 0; &#125;, &#125; &#125;; const wasmFileBuffer = fs.readFileSync(path.join(__dirname, &#x27;target/wasm32-wasi/debug/code-stock.wasm&#x27;)); wasmRes = await WebAssembly.instantiate(wasmFileBuffer, importObject); thisMemory = wasmRes.instance.exports.memory; // wasmRes.instance.exports._start &amp;&amp; wasmRes.instance.exports._start(); wasmRes.instance.exports.main(); console.log(&#123; consoleLogData, &#125;); &#125; catch(e) &#123; console.error(e); &#125;&#125;)(); 然后直接通过 node test.js 既可执行 wasm 代码 如何在浏览器环境执行 wasm 程序目前新版本的现代浏览器基本上都有 WebAssembly API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108(async () =&gt; &#123; try&#123; const env = &#123; PWD: &#x27;/&#x27; &#125;; let thisView = null; let wasmRes = null; let thisMemory = null; let consoleLogData = &#x27;&#x27;; const refreshMemory = () =&gt; &#123; if (!thisView || thisView.buffer.byteLength === 0) &#123; thisView = new DataView(thisMemory.buffer); &#125; &#125; const getiovs = (iovs, iovsLen) =&gt; &#123; refreshMemory(); const buffers = Array.from(&#123; length: iovsLen &#125;, (_, i) =&gt; &#123; const ptr = iovs + i * 8; const buf = thisView.getUint32(ptr, true); const bufLen = thisView.getUint32(ptr + 4, true); return new Uint8Array(thisMemory.buffer, buf, bufLen); &#125;); return buffers; &#125;; function Uint8ArrayToString(fileData)&#123; var dataString = &quot;&quot;; for (var i = 0; i &lt; fileData.length; i++) &#123; dataString += String.fromCharCode(fileData[i]); &#125; return dataString &#125; const importObject = &#123; wasi_snapshot_preview1: &#123; fd_write: (fd, iovs, iovsLen, nwritten) =&gt; &#123; let written = 0; const buffers = getiovs(iovs, iovsLen); buffers.forEach(buffer =&gt; &#123; consoleLogData+= Uint8ArrayToString(buffer); written+=buffer.length; &#125;); thisView.setUint32(nwritten, written, true); return 0; &#125;, environ_get: (environ, environBuf) =&gt; &#123; refreshMemory(); let coffset = environ; let offset = environBuf; Object.entries(env).forEach(([key, value]) =&gt; &#123; thisView.setUint32(coffset, offset, true); coffset += 4; offset += Buffer.from(thisMemory.buffer).write( `$&#123;key&#125;=$&#123;value&#125;\\0`, offset ); &#125;); return 0; &#125;, environ_sizes_get: (environCount, environBufSize) =&gt; &#123; refreshMemory(); const envProcessed = Object.entries(env).map( ([key, value]) =&gt; `$&#123;key&#125;=$&#123;value&#125;\\0` ); const size = envProcessed.reduce( (acc, e) =&gt; acc + Buffer.byteLength(e), 0 ); thisView.setUint32(environCount, envProcessed.length, true); thisView.setUint32(environBufSize, size, true); return 0; &#125;, proc_exit: (rval) =&gt; &#123; return 0; &#125;, &#125; &#125;; const wasmFileBuffer = fetch(&#x27;target/wasm32-wasi/debug/code-stock.wasm&#x27;); wasmRes = await WebAssembly.instantiate(wasmFileBuffer, importObject); thisMemory = wasmRes.instance.exports.memory; // wasmRes.instance.exports._start &amp;&amp; wasmRes.instance.exports._start(); wasmRes.instance.exports.main(); console.log(&#123; consoleLogData, &#125;); &#125; catch(e) &#123; console.error(e); &#125;&#125;)(); 什么是 wapm wamp官网: https://wapm.io/ wapm 全称是 webassembly Package management , 是一个线上的 wasm 二进制包管理仓库。作用类似于 node.js 的 npm 或 java 的 maven 我们可以在这个仓库上 发布自己的 wasm 程序，或者下载运行别人发布的 wasm 程序。 git repo rust 生成 wams: https://github.com/yunqiangwu/wasmide/tree/main/rust/code-stock node.js 调用 wams： https://github.com/yunqiangwu/wasmide/blob/main/rust/code-stock/test.js 浏览器环境执行 wams: https://github.com/yunqiangwu/wasmide/tree/main/ui","tags":[{"name":"wasm webassembly nodejs","slug":"wasm-webassembly-nodejs","permalink":"http://blog.jajabjbj.top/tags/wasm-webassembly-nodejs/"}]},{"title":"前端持续集成环境搭建","date":"2020-02-19T00:00:00.000Z","path":"2020/02/19/2020-02-19/","text":"jenkins + nginx 实现持续集成搭建jenkinsjenkins 是一个开源持续集成工具，安装非常简单，为了管理方便，这里使用 docker 进行安装。 安装 dockercentos 安装 docker 1sudo yum install docker 启动 docker 服务 1sudo systemctl start docker 安装 jenkins创建 jenkins 数据持久化目录 123sudo mkdir -p /datasudo chmod 777 /datamkdir -p /data/jenkins_home 通过docker容器安装jenkins 12345678910docker run \\ -u root \\ --rm \\ --name jenkins-server \\ -d \\ -p 8080:8080 \\ -p 50000:50000 \\ -v /data/jenkins_home:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ registry.cn-hangzhou.aliyuncs.com/hzero-cli/jenkins 关于 docker 命令的学习可以看这里 👉 Docker 命令大全 上面命令运行完成之后我们就已经成功运行了 jenkins 服务 我们可以打开地址 https:&#x2F;&#x2F;centos服务器ip:8080，可以看到 jenkins 的界面。 这里的 centos服务器ip 就是你自己的服务器 ip，在这个教程里面，我们演示的服务器ip是 172.22.0.4。 接下来我们需要获取jenkins初始化密码。 12docker exec -it jenkins-server \\ cat /var/jenkins_home/secrets/initialAdminPassword 这里返回的一段字符串6c46ccc61c804279a1017b743ab22aa4就是我们需要的密码 输入密码之后，选择安装初始化的插件 插件安装好之后，系统会提示你设置用户名密码，当然你也可以不设置，直接用 admin 账号。重新进入 jenkins 界面。点击输入账号里面，这里的密码就是上文获取到的 jenkins 初始化密码 6c46ccc61c804279a1017b743ab22aa4，点击登录，进入系统: 到此为止。jenkins 就算是安装好了 我们如果想要卸载 jenkins 的话，只需要运行 docker rm -f jenkins-server 就可以了。 因为我们配置了 jenkins 数据持久化的目录 /data/jenkins_home， 只要这个文件夹还在，jenkins 配置就可以一直保留，下次想运行 jenkins 是，运行上文安装 jenkins 的 docker run 命令就可以恢复 docker 运行了。 配置 jenkins 的 nodejs 插件安装完 jenkins 之后， 需要配置一下 nodejs 插件，后面才能让 jenkins 跑前端持续集成任务。 点击 系统管理 进入 jenkins 系统管理页面 点击 插件管理 进入插件管理 进入 可选插件 选项卡，搜索并安装 nodejs 插件 勾选 安装完成后重启选项，安装完插件之后 jenkins 会 自动重启 进入 全局工具配置 配置 nodejs 全局工具 点击 新增 NodeJS 按键新增一个 nodejs 全局工具，勾选 自动安装 注意: 安装 nodejs 时需要安装两个 node 全局命令 yarn 和 lerna, 然后点击保存。 测试 nodejs 插件我们安装完了 nodejs 插件之后，先回到首页 新建一个 jenkins 任务测试一下 nodejs。 点击 创建一个新任务 打开任务编辑界面选择 构建自由风格的软件项目， 输入一个任务名字test-node-demo: 在构建环境这里选择我们刚刚配置的 nodejs 全局工具 在构建这里 点击 增加构建步骤 ，在弹出的选项中选择 执行shell ： 在命令输入框中输入,然后点击保存按钮 12node -e &#x27;console.log(&quot;Hello Hzero!&quot;);&#x27;node --version 然后点击这个任务的 立即构建 按钮 构建时，在下面会出现一个进度条，点击进度条 可以看执行的日志 进入日志之后，将看到看到如下信息 到此，nodejs 插件测试成功！ 安装 nginxcentos 安装 nginx 也非常简单 ，一句命令 sudo yum install nginx 就能搞定， 但是这样安装 nginx 之后，配置管理和nginx升级都比较麻烦，所以我们这里用 docker 来安装 nginx 。 这里我们先定义两个文件目录，用来保存 nginx 的部署文件和 nginx 的配置 /data/nginx/wwwroot nginx 的部署文件夹 /data/nginx/nginx_hzero.conf hzero 的 nginx 配置 首先创建 nginx 数据持久化文件夹和 配置保存文件夹, 12sudo mkdir -p /data/nginx/wwwrootsudo mkdir -p /data/nginx/cfg 创建 nginx 配置文件, 保存在 /data/nginx/cfg/nginx_hzero.conf 在命令行运行下面命令： 12345678910111213141516171819202122232425262728293031323334353637# /data/nginx/cfg/nginx_hzero.confsudo -s # 进入root用户模式cat &gt; /data/nginx/cfg/nginx_hzero.conf &lt;&lt; ENDserver &#123; listen 80; server_name localhost; root /usr/share/nginx/html/dist; location / &#123; try_files \\$uri /index.html; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html/dist; &#125; # Media: images, icons, video, audio, HTC location ~* \\.(jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ &#123; expires 1M; access_log off; add_header Cache-Control &quot;public&quot;; &#125; # CSS and Javascript location ~* \\.(css|js)$ &#123; expires 1y; access_log off; add_header Cache-Control &quot;public&quot;; &#125;&#125;END 运行nginx镜像 123456789docker run \\ -u root \\ --rm \\ --name nginx \\ -d \\ -p 40080:80 \\ -v /data/nginx/cfg/:/etc/nginx/conf.d/ \\ -v /data/nginx/wwwroot/:/usr/share/nginx/html/ \\ nginx 添加测试文件 12sudo mkdir -p /data/nginx/wwwroot/distsudo echo Hello Nginx &gt; /data/nginx/wwwroot/dist/test.txt 测试 nginx 运行效果 1curl http://172.22.0.4:40080/test.txt 如果能显示 Hello Nginx 说明 nginx 安装成功 配置 jenkins 持续集成任务构建配置 jenkins 任务之前，我们先准备一个 hzero-front 工程的代码仓库地址：https://code.choerodon.com.cn/hft/hzero-front-demo.git 回到 jenkins 首页 新建一个 jenkins 任务。 点击 创建一个新任务 打开任务编辑界面选择 构建自由风格的软件项目， 输入一个任务名字hzero-front-ci: 点击保存后会进入任务编辑页面： 在任务编辑界面的源代码管理 选择 git 选项安装图片填写下面信息： Repository URL： 输入代码库地址（https://code.choerodon.com.cn/hft/hzero-front-demo.git） Credentials：添加 code.choerodon.com.cn 的账号密码 在编译环境设置里面勾选上 nodejs 工具。 添加一个构建步骤 执行 shell 输入下面的 shell 脚本: 123456789101112131415yarn installcat &gt; src/config/.env.production.yml.local &lt;&lt; ENDBASE_PATH: /PLATFORM_VERSION: SAASCLIENT_ID: localhostGENERATE_SOURCEMAP: falseAPI_HOST: http://backend.hft.jajabjbj.topWEBSOCKET_HOST: ws://ws.hft.jajabjbj.topSKIP_TS_CHECK_IN_START: falseENABLE_VUE_SUPPORT: falseSKIP_ESLINT_CHECK_IN_START: falseENDyarn run build:productiontar -zcf dist.tar.gz ./dist 点击保存。 下一步然后点击 立即构建，这里会构建并生成 dist 文件 部署构建完成生成了 dist 文件，下一步我们要把 构建生成的文件部署到 nginx 的 www 目录 /data/nginx/wwwroot 接下来我们配置一下 dist 部署流程 部署通常都是指把构建好的 dist 文件部署到远程服务器，部署的方法有很多，比如 ftp、 构建 docker等、ssh ， 这里我们演示一下如何通过 ssh 远程部署 dist 文件到 nginx 服务器上。 首先我们需要安装一个 jenkins 插件 Publish Over SSH。 插件的安装方法上文中有提到，这里就不再赘述。 安装好之后，打开 系统管理 &gt; 配置中心 把 nginx 服务器的信息 添加到 Publish Over SSH 的 ssh 配置。 对关键配置项的解释： name: 给服务器起一个名字，在后面设置任务时会用到这个名字。 Hostname: sshd 服务器的ip地址, 也就是 nginx 服务器ip地址。 Remote Directory: 这里是设置服务器上传目录，由于在 jenkins 任务里面可以配置， 为了不引起误解，这里设置成 / 就可以了。 Passphrase&#x2F;Password: 这里是服务器 ssh 登录密码，如果是通过私钥连接服务器，可以不输入密码。 Key: 这里是服务器的私钥文件内容。如果你是通过 密码 连接 ssh 服务器的话，可以不填私钥。 然后打开我们刚刚创建的 jenkins 任务，点击配置按钮，进入任务编辑页面。 到 Post-build Actions 配置部分添加一个 构建后的部署流程。 然后输入相应的配置 对关键配置项的解释： name: 上文在 系统管理 &gt; 配置中心 中配置的 ssh 服务器名字。 Source files: 制定上传到服务器的文件，注意这里的文件是上面我们配置的构建脚本产生的文件。 Remote directory: 这个是上传到远程服务器位置，上传上去的文件还是一个压缩包，后面还有在这个目录下执行节约命令 Exec command: 在远程服务器上执行的 shell 命令 123cd /data/nginx/wwwrootsudo rm -rf distsudo tar -zxf dist.tar.gz 然后点击保存，再构建一次。 看下构建日志。提示发布成功。 然后我们可以 在浏览器输入一下 nginx 服务器地址， 试试服务是否成功。 配置自动持续集成如果想实现完全自动的持续集成，还需要配置一个地方 打开任务配置设置一个触发选项 Poll SCM，设置 Schedule 规则为: H/15 * * * * 这里配置项的意思是：每 15 分钟检查一次 git 源代码仓库是否有新的变更，如果有就执行构建任务。 关于 cronjob 表达式的学习 jenkins + gh-pages 实现持续集成如果没有 nginx 服务器，我们也可以把 dist 部署到 gh-pages 上。 考虑到 github 的 gh-pages 网速在国内有些慢， 本教程就用国内的 gitee 做一个示范。 gitee网站: https://gitee.com/ 首先我们在 gitee 上面注册好账号，然后再创建一个代码仓库。 我们可以得到一个代码仓库地址：https://gitee.com/hzero-cli/hzero-front-demo-dist.git 部署到 gh-pages 上面我们需要用到一个 npm 工具 gh-pages: gh-pages 文档地址 把这个工具配置到 nodejs 的全局工具上面： 配置好工具之后，开始创建 jenkins 任务。 为了简便，我们基于之前的持续集成任务创建一个新的持续集成任务。 点击 新建任务 按钮 为任务起一个新名字： hzero-front-ci-gitee 注意这里我们要选择 Copy from, 输入前面创建的任务名字：hzero-front-ci 点击 ok ，进入构建配置部分。 修改构建脚本，添加 gh-pages 部署命令： 123git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;gh-pages -r https://hzero-cli:abcd1234@gitee.com/hzero-cli/hzero-front-demo-dist.git -b gh-pages -d dist 然后删除从 hzero-front-ci 任务复制过来的 ssh部署 配置 保存，点击立即构建。 这样构建生成的 dist 就可以发布到 gitee 代码仓库了。 这里会多一个分支，就是我们部署上去的文件。 接下来我们需要给 gitee 代码仓库设置一下 gh-pages 的 http 服务。 点击 服务 &gt; Gitee Pages 设置部署分支为 gh-pages ,然后点击开始按钮 运行成功之后， 我们得到一个 http 访问地址：http://hzero-cli.gitee.io/hzero-front-demo-dist/ 但是访问时， console 还是会报错: 这是因为 gitee 的 gh-pages 提供的 http 地址有一个根路径(public_path)。 所以我们修改一下构建的环境变量，打开任务的构建配置修改环境变量： 12PUBLIC_URL: /hzero-front-demo-dist/BASE_PATH: /hzero-front-demo-dist/ 注意一下 BASE_PATH 和 PUBLIC_URL 的区别。 PUBLIC_URL : 会影响资源加载路径，在资源加载路径前面加一层根路径。 BASE_PATH : 会影响浏览器的地址栏根路径。在地址栏显示的地址上加一层根路径。 虽然 BASE_PATH 不会影响资源加载路径，但是我们进入页面之后刷新，必须浏览器的地址栏是以 http://hzero-cli.gitee.io/hzero-front-demo-dist/ 为前缀，所以要加一下 BASE_PATH 的配置。 清除构建缓存，然后点击重新构建 注意: 由于 hzero-cli 默认开启了增量更新， 所以修改了环境变量之后，需要清空当前构建任务的缓存。 如果你访问页面，第二次刷新还会有 404 的问题 这是因为我们 gh-pages 和 nginx 配置 不一样。nginx 上面配置了一段代码： 123location / &#123; try_files $uri /index.html;&#125; 有了这段代码， 服务器就会路径找不到的http请求重新定位到 &#x2F;index.html 但是 gh-pages 的原理是: 如果当前 http 请求路径定位不到仓库的文件，就返回 404.html 的内容。 所以为了能让页面正常显示，我们还需要在脚本构建完成之后 加一行代码 cp dist/index.html dist/404.html让浏览器能获取到 index.html 。 最后脚本修改如下： 12345678910111213141516171819202122232425yarn installcat &gt; src/config/.env.production.local.yml &lt;&lt; ENDPUBLIC_URL: /hzero-front-demo-dist/BASE_PATH: /hzero-front-demo-dist/PLATFORM_VERSION: SAASCLIENT_ID: localhostGENERATE_SOURCEMAP: falseAPI_HOST: http://backend.hft.jajabjbj.topWEBSOCKET_HOST: ws://ws.hft.jajabjbj.topSKIP_TS_CHECK_IN_START: falseENABLE_VUE_SUPPORT: falseSKIP_ESLINT_CHECK_IN_START: falseENDyarn run build:productioncp dist/index.html dist/404.htmlgit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot;gh-pages-cleangh-pages -r https://hzero-cli:abcd1234@gitee.com/hzero-cli/hzero-front-demo-dist.git \\ -b gh-pages \\ -d dist 清除构建缓存之后，点击重新构建, 构建成功会自动部署，部署完成之后就可以访问： http://hzero-cli.gitee.io/hzero-front-demo-dist 了","tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://blog.jajabjbj.top/tags/jenkins/"}]},{"title":"使用高阶组件实现页面的表单数据和state缓存","date":"2018-08-29T00:00:00.000Z","path":"2018/08/29/cache/","text":"功能介绍当页面上存在 Antd 的 From表单,切换到其他页面再切换回来,希望表单的数据和页面状态数据能够保留, 使用使用 @cachePage 高阶组件完成相应的功能 实现原理定义一个Map缓存对象使用高阶组件包装一层 包含 From 表单的组件， 在高阶组件被加载时，在 componentDidMonent 方法中判断缓存对象中是否有该页面的数据， 如果有数据，就通过 From 表单的 Api ，把数据设置到组件的 From 数据里面， 在高阶组件销毁时，在组件的 componentWillUnMonent 方法中 把被包装组件的From表单的数据取出来 放到缓存对象中。 高阶代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import React, &#123; Component &#125; from &#x27;react&#x27;;import moment from &#x27;moment&#x27;;// 内存缓冲对象const cacheMap = &#123;&#125;;const cacheKeyList = [];/** * 缓存路由页面表单 keep-alive * * @param &#123;string&#125; cacheKey 缓存的key,对应每个路由页面的key, 默认 路由页面组件名称 * @propsMethod props.cachePage.clear() 清除缓存，并标记这次表单将不被缓存 * */export const cachePage = (&#123; cacheKey,&#125; = &#123;&#125;) =&gt; &#123; return (ComposedComponent) =&gt; &#123; let isError = false; if (!cacheKey) &#123; // console.warn(&#x27;缺失 CachePage 必填参数 cacheKey&#x27;); isError = true; &#125; if (cacheKeyList.indexOf(cacheKey) &gt;= 0) &#123; // console.warn(&#x27;CachePage ,cacheKey 必须保证全局唯一，多一个页面不能有相同 cacheKey &#x27;); // isError = true; &#125; if (isError) &#123; return ComposedComponent; &#125; cacheKeyList.push(cacheKey); // 当前是否应该保存cache（如果被调用收到清理cache，就在组件销毁时不保存cache） let shouldSave = true; const mCacheKey = cacheKey || ComposedComponent.id || ComposedComponent.key; // 获取cache const getCache = () =&gt; &#123; let cache = cache = cacheMap[mCacheKey]; if (!cache) &#123; cache = &#123;&#125;; cacheMap[mCacheKey] = cache; &#125; return cache; &#125;; // 保存cache const setCache = (cache) =&gt; &#123; cacheMap[mCacheKey] = cache; &#125;; // 清除cache const clearCache = (isClose) =&gt; &#123; delete cacheMap[mCacheKey] ; if (isClose) &#123; shouldSave = false; &#125; &#125;; return class WrapComponent extends Component &#123; componentDidMount() &#123; const &#123; form &#125; = this.props; const cacheData = getCache(); if (form &amp;&amp; cacheData.form) &#123; const &#123; setFieldsValue, getFieldProps &#125; = form; const cacheFormData = cacheData.form; Object.keys(cacheFormData).forEach((formKey) =&gt; &#123; getFieldProps(formKey); &#125;); // 设置数据到表单 setFieldsValue(cacheFormData); &#125; if (this.pageComponent &amp;&amp; cacheData.pageState) &#123; // 设置数据到页面组件state this.pageComponent.setState(cacheData.pageState); &#125; shouldSave = true; &#125; componentWillUnmount() &#123; if (shouldSave === false) &#123; return; &#125; const &#123; form &#125; = this.props; const cacheData = getCache(); // 获取页面组件表单数据 if (form) &#123; const &#123; getFieldsValue, getFieldProps &#125; = form; cacheData.form = getFieldsValue(); &#125; // 获取页面组件state数据 if (this.pageComponent &amp;&amp; this.pageComponent.state) &#123; cache.pageState = this.pageComponent.state; &#125; // 保存数据到缓存 setCache(cache); &#125; actionObj = &#123; clear() &#123; clearCache(); shouldSave = false; &#125;, &#125;; render() &#123; // eslint-disable-next-line react/no-string-refs return &lt;ComposedComponent ref=&#123;(c) =&gt; &#123; this.pageComponent = c; &#125;&#125; cachePage=&#123;this.actionObj&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;; &#125;;&#125;;/** * 让 Form 数据 JSON 反序列号支持 Date * @param key * @param value * @returns &#123;*&#125; */function dateReviver(key, value) &#123; if (typeof value === &#x27;string&#x27;) &#123; const a = /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)T(\\d&#123;2&#125;):(\\d&#123;2&#125;):(\\d&#123;2&#125;(?:\\.\\d*)?)Z$/.exec(value); if (a) &#123; return moment(new Date(value)); &#125; &#125; return value;&#125;export const onClosePage = (pathname) =&gt; &#123; if (pathnameToCacheKey[pathname]) &#123; pathnameToCacheKey[pathname](true); &#125;&#125;; 参数介绍 cacheKey 缓存的key,对应每个路由页面的key, 必填参数 方法在使用该高阶组件修饰的页面后, 页面的props内部会被注入一个cachePage对象,提供与以下操作缓存的方法: props.cachePage.clear() : 清除缓存，并标记这次表单将不被缓存, 在页面组件列通过this.props.cachePage.clear(), 跳转到其他页面时,数据不会被缓存,并且清空上次缓存的数据 使用案例在页面组件中加上这个注解，切换页面时，可以保留当前页面状态 12345678910111213141516171819202122232425262728import React, &#123; PureComponent &#125; from &#x27;react&#x27;;import &#123; Form, Input, &#125; from &#x27;antd&#x27;;import &#123; cachePage &#125; from &#x27;../../utils/Cache/cacheFromWrapper&#x27;;@Form.create()@cachePage(&#123; cacheKey: &#x27;BasicFormPage&#x27; &#125;)export default class BasicFormPage extends PureComponent &#123; const _style = &#123; marginTop: 8 &#125;; render()&#123; return (&lt;Form&#123; hideRequiredMark style=&#123;_style&#125; &gt; &lt;FormItem label=&quot;标题&quot; &gt; &#123;getFieldDecorator(&#x27;title&#x27;, &#123; rules: [&#123; required: true, message: &#x27;请输入标题&#x27;, &#125;], &#125;)( &lt;Input placeholder=&quot;给目标起个名字&quot; /&gt; )&#125; &lt;/FormItem&gt; &lt;/From&gt;); &#125;&#125; 功能扩展 通过可以在高阶组件里面把数据缓存到 localStorage 注意事项该高阶组件的表单缓存效果实现依赖 Antd 的 From.create()所以使用时,表单的创建必须用 antd 中的 From.create()生成表单","tags":[{"name":"react","slug":"react","permalink":"http://blog.jajabjbj.top/tags/react/"}]},{"title":"使用 openssl 生成证书","date":"2018-05-30T00:00:00.000Z","path":"2018/05/30/2018-05-30/","text":"使用 openssl 生成证书今天在配置kibana权限设置时，kibana要求使用https链接。 于是总结了一下linux下openssl生成 签名的步骤： x509证书一般会用到三类文，key，csr，crt。 Key 是私用密钥openssl格，通常是rsa算法。 Csr 是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。 crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。 key的生成 openssl genrsa -des3 -out server.key 2048 这样是生成rsa私钥，des3算法，openssl格式，2048位强度。server.key是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。可以通过以下方法生成没有密码的key: openssl rsa -in server.key -out server.key server.key就是没有密码的版本了。 生成CA的crt openssl req -new -x509 -key server.key -out ca.crt -days 3650 生成的ca.crt文件是用来签署下面的server.csr文件。 csr的生成方法 openssl req -new -key server.key -out server.csr 需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 crt生成方法 CSR文件必须有CA的签名才可形成证书，可将此文件发送到verisign等地方由它验证，要交一大笔钱，何不自己做CA呢。 openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key -CAcreateserial -out server.crt 输入key的密钥后，完成证书生成。-CA选项指明用于被签名的csr证书，-CAkey选项指明用于签名的密钥，-CAserial指明序列号文件，而-CAcreateserial指明文件不存在时自动生成。 最后生成了私用密钥：server.key和自己认证的SSL证书：server.crt 证书合并： cat server.key server.crt &gt; server.pem 配置docker 信任证书 123456789&#123; &quot;registry-mirrors&quot; : [ &quot;http://b36c9ea6.m.daocloud.io&quot; ], &quot;tlscacert&quot; : &quot;/data/cert/server.pem&quot;, &quot;debug&quot; : true, &quot;experimental&quot; : true&#125;","tags":[]},{"title":"搭建 gitlab-ci 持续集成环境","date":"2018-05-30T00:00:00.000Z","path":"2018/05/30/2018-05-31-1/","text":"搭建 gitlab-ci 持续集成环境安装dockerhttps://www.docker.com/get-docker 添加 hosts1234567# 「192.168.99.1 」 为宿主机的ip192.168.99.1 gitlab.jajabjbj.top192.168.99.1 rancher.jajabjbj.top192.168.99.1 jenkins.jajabjbj.top192.168.99.1 docker.jajabjbj.top192.168.99.1 harbor.jajabjbj.top 注意： 这里不能使用127.0.0.1，应为在docker容器中的127.0.0.1 和宿主机的127.0.0.1是两个不同的ip，如果docker容器内解析这个域名就好得到错误的ip，这里「192.168.99.1 」 为你宿主机电脑上面的虚拟网卡的固定ip，可以安装 VirtrualBox 等软件后，宿主机上面会自动创建虚拟网卡。 安装 nginx proxy安装 nginx-proxy 的目的是为了让宿主机器通过一个端口号，向外以多个不同容器的方式提供多个服务。 12345sudo docker run -d -p 80:80 --name nginx-proxy \\ -v /var/run/docker.sock:/tmp/docker.sock:ro \\ jwilder/nginx-proxy 安装gitlab1234567891011121314mkdir -p /srv/gitlabsudo docker run -d --privileged \\ --env GITLAB_OMNIBUS_CONFIG=&quot;external_url &#x27;http://gitlab.jajabjbj.top/&#x27;&quot; \\ --env VIRTUAL_HOST=gitlab.jajabjbj.top \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab \\ --volume /srv/gitlab/logs:/var/log/gitlab \\ --volume /srv/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 12345678# pages 服务gitlab_rails[&#x27;lfs_enabled&#x27;] = truepages_external_url &#x27;http://gitlab.jajabjbj.top&#x27;gitlab_rails[&#x27;pages_path&#x27;] = &quot;/tmp/pages&quot;gitlab_rails[&#x27;lfs_enabled&#x27;] = true 安装并添加 gitlab-runnerdocker 镜像运行方式123456&gt; mkdir -p /srv/gitlab/gitlab-runner&gt; docker run -d --name gitlab-runner --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ gitlab/gitlab-runner:latest 在gitlab 上创建一个项目，打开项目CI设置，在项目里面添加一个 gitlab-runner 添加界面会提供一个「gitlab-ci token」： UbK4qdLj1hvBsVxTSUJ5 123456789101112131415161718192021222324 &gt; docker exec -it gitlab-runner bash&gt; gitlab-ci-multi-runner register \\ --docker-volumes /var/run/docker.sock:/var/run/docker.sock \\ --docker-privilegedRunning in system-mode.Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://gitlab.jajabjbj.top/Please enter the gitlab-ci token for this runner:UbK4qdLj1hvBsVxTSUJ5Please enter the gitlab-ci description for this runner:[4857c90d8789]: mac-dockerPlease enter the gitlab-ci tags for this runner (comma separated):Whether to lock the Runner to current project [true/false]:[true]: falseRegistering runner... succeeded runner=UbK4qdLjPlease enter the executor: shell, ssh, docker+machine, docker, docker-ssh, parallels, virtualbox, docker-ssh+machine, kubernetes:dockerPlease enter the default Docker image (e.g. ruby:2.1):nodeRunner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! 注意gitlab-ci 中要使用docker in docker 时, 必须在gitlab-ci.yml 中添加 docker:dind ： 123image: docker:latestservices: - docker:dind","tags":[{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://blog.jajabjbj.top/tags/gitlab-ci/"}]},{"title":"使用 nginx-proxy 实现多个 docker容器以不同的域名共享宿主机80端口对外提供服务","date":"2018-05-30T00:00:00.000Z","path":"2018/05/30/2018-05-31/","text":"使用 nginx-proxy 实现多个 docker 容器以不同的域名共享宿主机80端口对外提供服务12docker run -d -p 80:80 -p 443:443 -v /var/run/docker.sock:/tmp/docker.sock:ro -v /data/cert:/etc/nginx/certs \\ --name my-nginx-proxy jwilder/nginx-proxy","tags":[{"name":"docker","slug":"docker","permalink":"http://blog.jajabjbj.top/tags/docker/"}]},{"title":"本地安装 kubernetes 环境","date":"2018-05-30T00:00:00.000Z","path":"2018/05/30/2018-06-03/","text":"安装 k8s 准备安装 Kubernetes https://yq.aliyun.com/articles/221687 Mac OSX 1curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.25.2/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ Linux 1curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.25.2/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ Windows 下载 minikube-windows-amd64.exe 文件，并重命名为 minikube.exe 自己构建 也可以从Github上获取相应的项目自行构建。 注：需要本地已经安装配置好 Golang 开发环境和Docker引擎 12345git clone https://github.com/AliyunContainerService/minikubecd minikubegit checkout aliyun-v0.25.0makesudo cp out/minikube /usr/local/bin/ 启动 k8s &amp; docker 缺省Minikube使用VirtualBox驱动来创建Kubernetes本地环境 1minikube start --registry-mirror=https://registry.docker-cn.com 打开Kubernetes控制台 1minikube dashboard","tags":[{"name":"k8s","slug":"k8s","permalink":"http://blog.jajabjbj.top/tags/k8s/"}]},{"title":"CSS 常用代码锦囊","date":"2018-05-22T00:00:00.000Z","path":"2018/05/22/2018-05-22-1/","text":"CSS 常用代码锦囊 三行文本溢出显示省略号 1234567891011121314151617181920212223242526.textOverflow3 &#123; overflow: hidden; position: relative; line-height: 1.5em; max-height: 4.5em; text-align: justify; margin-right: -1em; padding-right: 1em; &amp;:before &#123; background: #000; content: &#x27;...&#x27;; padding: 0 1px; position: absolute; right: 14px; bottom: 0; &#125; &amp;:after &#123; background: white; content: &#x27;&#x27;; margin-top: 0.2em; position: absolute; right: 14px; width: 1em; height: 1em; &#125;&#125; 文本溢出省略 123456789101112.textoverflow a &#123; display:block; width:120px; margin: 0px 0px 0px 3px; white-space: nowrap; overflow: hidden; float: left; -o-text-overflow: ellipsis; /* for Opera */ text-overflow: ellipsis; /* for IE */&#125;.textoverflow:after&#123; content: &quot;...&quot;; &#125;/* for Firefox */@media all and (min-width: 0px)&#123; .textoverflow:after&#123; content:&quot;&quot;; &#125;/* for Opera */ &#125; 多栏CSS3 使用css3来创建多栏，它可以自适应网页，不兼容IE 123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; See the Pen 2048 game by Cam Song (@camsong) on CodePen. ---","tags":[{"name":"css","slug":"css","permalink":"http://blog.jajabjbj.top/tags/css/"}]},{"title":"git 常用命令锦囊","date":"2018-05-22T00:00:00.000Z","path":"2018/05/22/2018-05-22/","text":"git 常用命令锦囊 获取当前 项目 git url 12git remote show # origingit config remote.origin.url # &#123;git url&#125; 获取当前分支 1git symbolic-ref --short -q HEAD # master","tags":[{"name":"git","slug":"git","permalink":"http://blog.jajabjbj.top/tags/git/"}]},{"title":"服务器端渲染程序 demo 图床","date":"2018-05-20T00:00:00.000Z","path":"2018/05/20/2018-05-23/","text":"服务器端渲染程序 demo 图床 Github: https://github.com/yunqiangwu/jj-image-bed.git 基于Webpack工程化解决方案easywebpack构建项目基于 Egg + React + Webpack3 + 七牛云存储 单页面服务端渲染同构工程图床Demo项目 Egg 版本： ^2.x.x Node 版本: Node ^8.x.x+ Webpack 版本: ^3.10.0, 对应 easywebpack-react 版本为 3.6.0 React 版本: ^15.0.0, ^16.0.0, qiniu 版本: 7.1.7 特性 基于 React 单页面服务端客户端同构实现 支持服务端渲染 render 和纯前端渲染 renderClient 支持 react-router, react-redux 服务端&#x2F;客户端单页面渲染 Node 8 版本的 async 和 await 特性, Controller 采用 class 方式编写 图片保存到七牛云 拖拽上传图片 依赖 easywebpack ^3.5.3 easywebpack-react ^3.5.0 egg-view-react-ssr ^2.1.0 egg-webpack ^2.4.6 egg-webpack-react ^2.0.0 使用Clone 项目1git clone https://github.com/yunqiangwu/jj-image-bed.git 安装依赖12npm installnpm start 启动应用1npm start 应用访问: http://127.0.0.1:7001 项目构建12345// 直接运行(编译文件全部在内存里面,本地开发使用)npm start// 编译文件到磁盘打包使用(发布正式环境)npm run build 或者 easywebpack build prod 项目截图 TODO 拖拽上传 粘贴图片 相册管理 LicenseMIT","tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.jajabjbj.top/tags/webpack/"}]},{"title":"《深入浅出NodeJS》 读书学习总结","date":"2018-05-20T00:00:00.000Z","path":"2018/05/20/abcd-a-d-asd/","text":"《深入浅出NodeJS》 读书学习总结 成果 文档: JavaScript异步编程的机制和相关编程技巧 项目 node 爬虫 服务器端渲染程序 demo 图床 读书笔记 NodeJS 5个特点：异步I&#x2F;O,事件驱动与回调，单线程事件轮询，跨平台。 NodeJS 5个大坑：异常处理，嵌套太深，没有Sleep，多线程编程，异步转同步。 NodeJS 4种提升性能的方法：动静分离，缓存（Redis）,多进程，数据库读写分离。 NodeJS简介 高性能，符合时间驱动，没有历史包袱这三个主要原因，JavaScript成为了Node的实现语言。 NodeJS基于Google V8引擎。Node优秀的运算能力主要来自V8的深度优化。 NodeJS特点：异步I&#x2F;O,事件驱动与回调函数，单线程事件轮询，跨平台 NodeJS单线程的缺点： 无法利用多核CPU. 错误会引起整个应用进程退出。 大量计算占用CPU导致无法继续调用异步I&#x2F;O. 解决单线程缺点的方法是引入子进程方法（Cluster,见后边）和C&#x2F;C++模块扩展（利用它们的多线程机制）。 模块机制 Node出现之前，服务器端的JS基本没有市场的。 CommonJS主要是为了弥补当前JS没有标准的缺陷，希望JS能够在任何地方运行。 模块引用var xxx = require(‘模块标识’); 例如：var math = require(‘math’); 模块定义模块中module对象代表模块自身，exports对象是module的属性，用于导出当前模块的方法或者变量，它是唯一导出的出口。module和exports是node在编译过程中给加上去的。 NodeJS中，一个文件就是一个模块，将方法或者变量挂在在exports对象上作为属性即可定义导出的方式: 12345678910111213exports.xxx = ……例如： exports.add = function()&#123;var sum = 0;var i = 0;….return sum;&#125; （exports和module.exports区别见后） 模块标识就是传给require()的参数。它必须符合小驼峰命名的字符串，或者以。，。。开头的相对路径，或者绝对路径。可以有或者没有文件后缀名（最好有后缀，p&#x2F;17）. 模块标识分类: 核心模块，如http, fs, path等。 .或者..开始的相对路径文件模块。 以&#x2F;开始的绝对路径文件模块。 非路径形式的文件模块，如自定义的connect模块。 Node中引入模块步骤（找文件-&gt;找文件扩展名-&gt;编译执行） 路径分析：定位文件位置，标识符中有路径，甚至没有。 文件定位：标识符中没有文件扩展名，所以需要确定类型。 编译执行：不同文件类型，载入方式不一样。 Node中模块分类 核心模块（Node提供）：核心模块在Node源代码的编译过程中，编译进了二进制文件，在Node进程启动时，部分核心模块就被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两步省略掉，且在路径分析时优先判断，所以核心模块加载速度是最快的。 文件模块（用户编写）：在运行时动态加载，三步骤都需要。Node对引用过的模块都会进行缓存，以减少二次引入时的开销。 模块路径分析策略即node在定位文件模块的具体文件时指定的查找策略。其策略是从当前node-modules开始一级一级向根的node-modules查找，核心模块最快，相对、绝对路径模块次之，自定义文件模块最慢。所以引用模块时，最好加上路径以及扩展名！ 文件定位策略 因为模块标识符中可以不包含文件扩展名，在这种情况下，Node会按照.js, .json, .node的次序补足扩展名，依次尝试。在尝试的过程中，需要调fs模块的同步阻塞式的判断文件是否存在，所以最好传入文件扩展名。 require（）通过分析文件扩展之后，可能没找到对应的文件，但却得到了一个目录，此时node会将目录当做一个包来出来（node对包处理会遵守CommonJS包规范）。 Node中，每个文件模块都是一个对象，定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。不同的文件扩展名，其载入和编译的方法也不一样： .js文件：通过fs模块同步读取文件后编译执行。 .node文件：这是C&#x2F;C++编写的扩展文件，通过process.dlopen（）方法加载和执行。它不需要编译，因为它是编写C&#x2F;C++模块之后编译生成的. C&#x2F;C++带来的优势主要是执行效率方面的。 .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果。 .其余扩展名文件：当做.js文件处理。 JS模块中require, exports, module这三个变量在模块中并没有定义，是node在编译过程中给加上的，这样每个模块中这三个变量的作用域是隔离的。 exports和module.exports区别： exports指向module.exports的引用, require（）返回的是module.exports而不是exports.如果module.exports指向了一个新对象则exports则断开了对module.exports的引用。刚开始module.exports为空对象，所以exports收集的属性和方法都赋给module.exports，而一旦module.exports有了属性，方法，则exports收集的信息将被忽略，所以在不调用module.exports时，采用exports. Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块分为C&#x2F;C++编写的和JS编写的两部分。而在编译所有的C&#x2F;C++文件之前，编译程序需要将所有的JS模块文件编译为C&#x2F;C++代码。 包包和NPM是将模块联系起来的一种机制 包组织模块示意图：包实际上是一个存档文件，即一个目录直接打包为.zip，安装解压还原为目录。 包结构： package.json:包描述文件。（详细说明p&#x2F;35） bin:用于存放可执行二进制文件的目录。 Lib:用于存放js代码的目录。 Doc:存放文档的目录。 Test:存放单元测试用例的代码。 产品化构建工具构建工具完成的功能主要是合并静态文件，压缩文件大小，打包应用，编译模块等。Grunt是跨平台的构建工具，它通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。代码检测工具JSLint可以通过gitlab等开源工具搭建了内部的代码托管平台。 Node提升性能的4个方法： 动静分离：node处理静态文件的能力不算突出。将图片，脚本，样式表和多媒体等静态文件都导入到专业的静态文件服务器（比如Nginx）上,让node只处理动态请求即可。 启用缓存Redis或Memcached. 多进程架构– cluster模块。 数据库读写分离：就任意数据库而言，读取的速度远远高于写入的速度。而某些数据库在写入时为了保证数据一致性，会进行锁表操作，这同时会影响到读取的速度。为了提升性能，通常会进行数据库的读写分离，将数据库进行主从设计。这样读数据操作不再受写入的影响了。 日志在node中可用connect提供的日志中间件来记录访问日志，当然我们可以在Nginx反向代理里记录访问日志。异常日志的实现：p&#x2F;296-298Node通过nodemailer模块实现邮件报警。 调试NodeJSNode调试可用三种方法：Debugger, console.log()和Node-InspectorDebugger:需要通过debugger;语句在代码中设置断点。使用方法p&#x2F;310 - 311Node-Insepector:可在浏览器中进行调试 或者公共idea 工具调试。 编程规范 缩进：采用两个空格而不是Tab 变量声明：永远用var声明变量 空格：操作符前后需要加空格 单双引号的使用：尽量使用单引号，这样无需转译 大括号的位置：大括号{无需另起一行 逗号：如果逗号不在行结尾，后面需要一个空格 分号：给表达式结尾添加分号 变量命名：小驼峰式 方法命名：小驼峰式 类命名：大驼峰式 常量命名：所有字母大写，以下划线分割 文件命名：采用下划线分割单词","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.jajabjbj.top/tags/nodejs/"}]},{"title":"JavaScript异步编程的机制和相关编程技巧","date":"2018-05-10T00:00:00.000Z","path":"2018/05/10/2018-05-19/","text":"JavaScript异步编程的机制和相关编程技巧JavaScript异步编程机制JavaScript异步编程机制简单来说就是 callback 机制实现的效果。callback形式的代码写复杂的异步编程，很容易出现callback地狱的问题，不利于代码的维护和管理，而Promise和es6的async可以很好的解决这个问题，使得写异步编程编的非常简单。 Promise是什么简单来说，Promise 主要就是为了解决异步回调的问题。用 Promise 来处理异步回调使得代码层次清晰，便于理解，且更加容易维护。其主流规范目前主要是 Promises&#x2F;A+ 。Promise 原理大概就类似这个样子 123456789101112131415161718// demo.1.jsfunction Promise(fn) &#123; let callback; let rejectCallback; //一个实例的方法，用来注册异步事件 this.then = function (done, errCallback) &#123; callback = done; rejectCallback = errCallback; &#125; function resolve() &#123; callback(); &#125; try &#123; fn(resolve); &#125; catch (e) &#123; rejectCallback(e); &#125;&#125; 使用Promise 12345678910111213function timeout3(callback) &#123; setTimeout(() =&gt; &#123; callback(&#x27;abcd&#x27;) &#125;, 3000)&#125;new Promise(timeout3).then((data) =&gt; &#123; console.log(3)&#125;);// # console: // 3 (三秒后屏幕出现 ) 这里只是简单的模拟一下Promise的代码，还有一下Promise的api没有全部实现，可以去深入研究Promise的源码，搞懂 Promise的 实现原理，能改使用Promise编程更加得心应手的. 使用Promise封装 node 的 http.request方法，实现简单的 fetch api 效果封装fetch API123456789101112131415161718192021222324252627282930313233343536373839404142// demo.2.jsconst http=require(&#x27;http&#x27;);const fetch = (url,fetchOptions = &#123;&#125;) =&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; var match = /((http|ftp|https):\\/\\/)((([a-zA-Z0-9\\._-]+\\.[a-zA-Z]&#123;2,6&#125;)|([0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;))(:[0-9]&#123;1,4&#125;)*(\\/[a-zA-Z0-9\\&amp;\\%_\\.\\/-~-]*)?)/; const matchObj = match.exec(url); if(!matchObj)&#123; reject(&#123; message: url+&#x27;域名格式不正确&#x27;, &#125;); &#125; const [,,,,,hostname,,,,path] = matchObj; var options = &#123; &quot;method&quot;: &quot;GET&quot;, hostname, path, &#125;; var req = http.request(options, function (res) &#123; var chunks = []; res.on(&quot;data&quot;, function (chunk) &#123; chunks.push(chunk); &#125;); res.on(&#x27;error&#x27;, (e) =&gt; &#123; reject(e); &#125;) res.on(&quot;end&quot;, function () &#123; var body = Buffer.concat(chunks); resolve(&#123; json:()=&gt;Promise.resolve(JSON.parse(body.toString())), blob: ()=&gt;Promise.resolve(body), text: ()=&gt;Promise.resolve(body.toString()), &#125;); &#125;); &#125;); req.end(); &#125;);&#125; 简单的调用fetch123456fetch(&#x27;http://www.mmjpg.com/&#x27;) .then(data=&gt;data.text()) .then(str=&gt;&#123; // 输出网页源码 console.log(str); &#125;) fetch链式调用12345678910111213141516171819202122232425262728// demo.3.jsconst fetch = require(&#x27;./demo.2&#x27;);fetch(&#x27;http://www.mmjpg.com/&#x27;) .then(data =&gt; data.text()) .then(content =&gt; &#123; const url = /(http:\\/\\/www.mmjpg.com\\/mm\\/\\d+)/.exec(content)[1]; return fetch(url).then(data=&gt;data.text()) .then(data =&gt; &#123; const n = /var\\s*picinfo\\s*=\\s*\\[(\\d+),(\\d+),(\\d+),(\\d+)\\]/.exec(data)[3]; console.log(n); return Array.from(&#123;length: n&#125;).map((item,index)=&gt;&#123; return url+&#x27;/&#x27;+(index+1); &#125;); &#125;); &#125;) .then(imageUrls =&gt; &#123; console.log(imageUrls); &#125;)// # console:// 60// [ &#x27;http://www.mmjpg.com/mm/1355/1&#x27;,// ...// ...// &#x27;http://www.mmjpg.com/mm/1355/59&#x27;,// &#x27;http://www.mmjpg.com/mm/1355/60&#x27; ] fetch按顺序批量获取url内容1234567891011121314151617181920212223242526272829303132333435// demo.4.jsconst fetch = require(&#x27;./demo.2&#x27;);const imgUrls = [&#x27;http://www.mmjpg.com/mm/1355/1&#x27;, &#x27;http://www.mmjpg.com/mm/1355/2&#x27;, &#x27;http://www.mmjpg.com/mm/1355/3&#x27;, &#x27;http://www.mmjpg.com/mm/1355/4&#x27;, &#x27;http://www.mmjpg.com/mm/1355/7&#x27;, &#x27;http://www.mmjpg.com/mm/1355/8&#x27;, &#x27;http://www.mmjpg.com/mm/1355/57&#x27;, &#x27;http://www.mmjpg.com/mm/1355/58&#x27;, &#x27;http://www.mmjpg.com/mm/1355/59&#x27;, &#x27;http://www.mmjpg.com/mm/1355/60&#x27;];const fetchImg = (urls, index=0, currentResult = []) =&gt; &#123; const url = urls[index]; if (url) &#123; return fetch(url) .then(data =&gt; data.blob()) .then(buffer =&gt; &#123; console.log(&#x27;Progress: &#x27; + index + &#x27;/&#x27; + urls.length) return fetchImg(urls, index + 1, [...currentResult, buffer]) &#125;) &#125; else &#123; return Promise.resolve(currentResult); &#125;&#125;fetchImg(imgUrls) .then(bufferList =&gt; &#123; // save imgBuffer to file... console.log(bufferList.length); &#125;) // console: /*Progress: 0/60Progress: 1/60......Progress: 58/60Progress: 59/60*/ 使用异步编程Promise.all优化后的效果12345678910111213// demo.5.jsconst fetch = require(&#x27;./demo.2&#x27;);const imgUrls = [&#x27;http://www.mmjpg.com/mm/1355/1&#x27;, &#x27;http://www.mmjpg.com/mm/1355/2&#x27;, &#x27;http://www.mmjpg.com/mm/1355/3&#x27;, &#x27;http://www.mmjpg.com/mm/1355/4&#x27;, &#x27;http://www.mmjpg.com/mm/1355/5&#x27;, &#x27;http://www.mmjpg.com/mm/1355/6&#x27;, &#x27;http://www.mmjpg.com/mm/1355/57&#x27;, &#x27;http://www.mmjpg.com/mm/1355/58&#x27;, &#x27;http://www.mmjpg.com/mm/1355/59&#x27;, &#x27;http://www.mmjpg.com/mm/1355/60&#x27;];Promise.all(imgUrls.map(url=&gt;fetch(url).then(data=&gt;data.blob()))) .then(bufferList=&gt; &#123; // save imgBuffer to file... console.log(bufferList.length); &#125;); es6中async使用 Promise.all123456789101112131415// demo.6.jsconst fetch = require(&#x27;./demo.2&#x27;);const imgUrls = [&#x27;http://www.mmjpg.com/mm/1355/1&#x27;, &#x27;http://www.mmjpg.com/mm/1355/2&#x27;, &#x27;http://www.mmjpg.com/mm/1355/3&#x27;, &#x27;http://www.mmjpg.com/mm/1355/4&#x27;, &#x27;http://www.mmjpg.com/mm/1355/5&#x27;, &#x27;http://www.mmjpg.com/mm/1355/6&#x27;, &#x27;http://www.mmjpg.com/mm/1355/7&#x27;, &#x27;http://www.mmjpg.com/mm/1355/8&#x27;, &#x27;http://www.mmjpg.com/mm/1355/9&#x27;, &#x27;http://www.mmjpg.com/mm/1355/10&#x27;, &#x27;http://www.mmjpg.com/mm/1355/11&#x27;, &#x27;http://www.mmjpg.com/mm/1355/12&#x27;, &#x27;http://www.mmjpg.com/mm/1355/13&#x27;, &#x27;http://www.mmjpg.com/mm/1355/14&#x27;, &#x27;http://www.mmjpg.com/mm/1355/15&#x27;, &#x27;http://www.mmjpg.com/mm/1355/16&#x27;, &#x27;http://www.mmjpg.com/mm/1355/17&#x27;, &#x27;http://www.mmjpg.com/mm/1355/18&#x27;, &#x27;http://www.mmjpg.com/mm/1355/19&#x27;, &#x27;http://www.mmjpg.com/mm/1355/20&#x27;, &#x27;http://www.mmjpg.com/mm/1355/21&#x27;, &#x27;http://www.mmjpg.com/mm/1355/22&#x27;, &#x27;http://www.mmjpg.com/mm/1355/23&#x27;, &#x27;http://www.mmjpg.com/mm/1355/24&#x27;, &#x27;http://www.mmjpg.com/mm/1355/25&#x27;, &#x27;http://www.mmjpg.com/mm/1355/26&#x27;, &#x27;http://www.mmjpg.com/mm/1355/27&#x27;, &#x27;http://www.mmjpg.com/mm/1355/28&#x27;, &#x27;http://www.mmjpg.com/mm/1355/29&#x27;, &#x27;http://www.mmjpg.com/mm/1355/30&#x27;, &#x27;http://www.mmjpg.com/mm/1355/31&#x27;, &#x27;http://www.mmjpg.com/mm/1355/32&#x27;, &#x27;http://www.mmjpg.com/mm/1355/33&#x27;, &#x27;http://www.mmjpg.com/mm/1355/34&#x27;, &#x27;http://www.mmjpg.com/mm/1355/35&#x27;, &#x27;http://www.mmjpg.com/mm/1355/36&#x27;, &#x27;http://www.mmjpg.com/mm/1355/37&#x27;, &#x27;http://www.mmjpg.com/mm/1355/38&#x27;, &#x27;http://www.mmjpg.com/mm/1355/39&#x27;, &#x27;http://www.mmjpg.com/mm/1355/40&#x27;, &#x27;http://www.mmjpg.com/mm/1355/41&#x27;, &#x27;http://www.mmjpg.com/mm/1355/42&#x27;, &#x27;http://www.mmjpg.com/mm/1355/43&#x27;, &#x27;http://www.mmjpg.com/mm/1355/44&#x27;, &#x27;http://www.mmjpg.com/mm/1355/45&#x27;, &#x27;http://www.mmjpg.com/mm/1355/46&#x27;, &#x27;http://www.mmjpg.com/mm/1355/47&#x27;, &#x27;http://www.mmjpg.com/mm/1355/48&#x27;, &#x27;http://www.mmjpg.com/mm/1355/49&#x27;, &#x27;http://www.mmjpg.com/mm/1355/50&#x27;, &#x27;http://www.mmjpg.com/mm/1355/51&#x27;, &#x27;http://www.mmjpg.com/mm/1355/52&#x27;, &#x27;http://www.mmjpg.com/mm/1355/53&#x27;, &#x27;http://www.mmjpg.com/mm/1355/54&#x27;, &#x27;http://www.mmjpg.com/mm/1355/55&#x27;, &#x27;http://www.mmjpg.com/mm/1355/56&#x27;, &#x27;http://www.mmjpg.com/mm/1355/57&#x27;, &#x27;http://www.mmjpg.com/mm/1355/58&#x27;, &#x27;http://www.mmjpg.com/mm/1355/59&#x27;, &#x27;http://www.mmjpg.com/mm/1355/60&#x27;];const fetAllData = async () =&gt; &#123; const bufferList = await Promise.all(imgUrls.map(url=&gt;fetch(url).then(data=&gt;data.blob()))); // save imgBuffer to file... console.log(bufferList.lenght);&#125;fetAllData();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.jajabjbj.top/tags/javascript/"}]},{"title":"用 jest + gitlab-ci 搭建前端UI自动化测试环境","date":"2018-05-09T00:00:00.000Z","path":"2018/05/09/2018-05-21/","text":"用 jest + gitlab-ci 搭建前端UI自动化测试环境前言下面以 github创建仓库为例 测试领域中比较麻烦的就是前端UI测试gitlab地址： https://gitlab.com/yunqiangwu/devops-test.git 前置要求 拥有gitlab账号(公司内部的也可以) gitlab 已经配置了 CI Runner(具体方法百度) 功能实现效果 修改过测试用例后push触发自动测试 测试完成后生成测试报告 测试报告部署到 git pages 上 发送邮件通知测试结果，以及报告查看链接 先看下我在实际项目中的效果，下面是我收到的自动化测试完成后的邮件： 预览地址自动化测试报告测试覆盖率报告 创建项目123456789mkdir devops-testcd devops-testnpm init # 初始化 `node` 项目 # 这里会要你输入信息，节约时间，一路回车# 下面的操作我用的是cnpm cnpm i jest jest-report nightmare --savecnpm i babel-jest babel-plugin-import babel-plugin-transform-class-properties babel-plugin-transform-decorators-legacy babel-plugin-transform-runtime babel-preset-env --save-dev# 重点依赖库介绍： jest 测试框架 nightmare 浏览器运行库 jest-report 测试报告生产库 配置jest环境 在 package.json 的 scripts 中叫如 test 命令 12345678910111213&#123; &quot;name&quot;: &quot;devops-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest e2e.js&quot; &#125;, &quot;author&quot;: &quot;&quot;, // ... &#125; 创建jasmine配置文件 项目根目录/tests/jasmine.js 配置测试超时时间 1jasmine.DEFAULT_TIMEOUT_INTERVAL = 12000; // 只有这一行内容 在package.json 中添加两个字段 babel 和 jest ,这样就能跑 es6 的代码 12345678910111213141516171819202122232425262728&#123; &quot;name&quot;: &quot;devops-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, // ... &quot;babel&quot;: &#123; &quot;presets&quot;: [ &quot;env&quot; ], &quot;plugins&quot;: [ &quot;transform-decorators-legacy&quot;, &quot;transform-class-properties&quot;, &quot;transform-es2015-destructuring&quot; ] &#125;, &quot;jest&quot;: &#123; &quot;testResultsProcessor&quot;: &quot;jest-report&quot;, &quot;setupTestFrameworkScriptFile&quot;: &quot;&lt;rootDir&gt;/tests/jasmine.js&quot;, &quot;testMatch&quot;: [ &quot;**/?(*.)(spec|test|e2e).js?(x)&quot; ] &#125;, // ... &#125; 编写测试用例测试github登录功能&lt;rootDir&gt;/src/e2e/test-github-login.e2e.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import Nightmare from &#x27;nightmare&#x27;;import &#123; helperBuilder &#125; from &#x27;jest-report&#x27;;describe(&#x27;Login&#x27;, () =&gt; &#123; let page; beforeEach(() =&gt; &#123; page = Nightmare(&#123; show: true &#125;).viewport(1024, 768); page.goto(&#x27;https://github.com/login&#x27;); &#125;); // afterEach(() =&gt; &#123; // if(page)&#123; // page.halt(); // page = null; // &#125; // &#125;); it(&#x27;should login with failure&#x27;, async() =&gt; &#123; const reportHelper = helperBuilder(&#x27;Login&#x27;, &#x27;should login with failure&#x27;); reportHelper.monitorPage(page); await page .type(&#x27;#login_field&#x27;, &#x27;mockuser&#x27;) .type(&#x27;#password&#x27;, &#x27;wrong_password&#x27;) .click(&#x27;input[type=&quot;submit&quot;]&#x27;) .wait(&#x27;#js-flash-container &gt; div &gt; div&#x27;); // should display error await page.screenshot(reportHelper.genPicturePath()); const text = await page.wait(&#x27;#js-flash-container &gt; div &gt; div&#x27;) .evaluate(() =&gt; document.body.innerText) .end(); await page.end(); expect(text).toContain(&#x27;Incorrect username or password&#x27;); &#125;); it(&#x27;should login successfully&#x27;, async() =&gt; &#123; const reportHelper = helperBuilder(&#x27;Login&#x27;, &#x27;should login successfully&#x27;); reportHelper.monitorPage(page); await page .type(&#x27;#login_field&#x27;, &#x27;正确用户名&#x27;) .type(&#x27;#password&#x27;, &#x27;正确密码&#x27;) .click(&#x27;input[type=&quot;submit&quot;]&#x27;) .wait(&#x27;#your_repos &gt; div &gt; div.boxed-group-action &gt; a&#x27;); // should display error await page.screenshot(reportHelper.genPicturePath()); const title = await page .evaluate(() =&gt; document.title) .end(); await page.end(); expect(title).toBe(&#x27;GitHub&#x27;); &#125;);&#125;); 运行测试生成测试报告1. 执行命令npm test，运行测试脚步 2. 生成测试报告生成的文件路径默认是 `&lt;rootDir&gt;/dist/test-report` 3. 测试报告效果 添加项目到gitlab123456git initgit remote add origin https://gitlab.com/yunqiangwu/devops-test.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master 添加到持续集成自动部署测试报告 到gitlab pages 网页 1cnpm i --save-dev gh-pages 在 package.json 添加 scripts 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest e2e.js&quot;, &quot;site&quot;: &quot;gh-pages -d dist&quot;&#125;, 配置邮件通知工具 &lt;rootDir&gt;/tool/emailnotice.sh 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashMAIL_FROM=&#x27;supportman@yeah.net&#x27;# [[ $MAIL_TO == &quot;&quot; ]] &amp;&amp; export MAIL_TO=$1MAIL_TO_ARR_ARG=$1MAIL_SUBJECT=$2shift 2MAIL_CONTENT=$*MAIL_CONTENT_FILE=&quot;/tmp/`/bin/date +%s`.txt&quot;MAIL_SMTP=&#x27;smtp://smtp.yeah.net&#x27;MAIL_USER=&#x27;supportman@yeah.net&#x27;MAIL_PASSWORD=&#x27;wu950429&#x27;OLD_IFS=&quot;$IFS&quot;#设置分隔符IFS=&quot;,&quot;MAIL_TO_ARR=($MAIL_TO_ARR_ARG)IFS=&quot;$OLD_IFS&quot;split_1()&#123; MAIL_TO=$1 echo &quot;发送邮件到：&quot;$1 # return 0; # create mail content file echo &quot;From:$&#123;MAIL_FROM&#125;To:$MAIL_TOSubject: $MAIL_SUBJECT$MAIL_CONTENT&quot;&gt; $&#123;MAIL_CONTENT_FILE&#125; # send mail curl -s --url &quot;$&#123;MAIL_SMTP&#125;&quot; --mail-from &quot;$&#123;MAIL_FROM&#125;&quot; --mail-rcpt $&#123;MAIL_TO&#125; --upload-file $&#123;MAIL_CONTENT_FILE&#125; --user &quot;$&#123;MAIL_USER&#125;:$&#123;MAIL_PASSWORD&#125;&quot;&#125;for s in $&#123;MAIL_TO_ARR[@]&#125;dosplit_1 &quot;$s&quot;donerm -rf $&#123;MAIL_CONTENT_FILE&#125; gitlab-ci.yml 配置文件 .gitlab-ci.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344image: jonneywu/node-xvfb-cnpmcache: key: &quot;$CI_REPOSITORY_URL&quot; paths: - node_modules - diststages: - test - emailtest: script: - if [ ! -d node_modules ]; then cnpm i; fi - if [ ! -d node_modules/nightmare ]; then cnpm i nightmare; fi - export DISPLAY=&#x27;:99.0&#x27; - Xvfb :99 -screen 0 1024x768x24 &gt; /dev/null 2&gt;&amp;1 &amp; - npm run test &amp;&amp; echo test FAIL - kill -9 `ps -ef | grep Xvfb| grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;` - npm run site stage: test only: - master artifacts: paths: - distemail: script: - echo email - if [[ ! -n $MAIL_TO ]]; then export MAIL_TO=842269153@qq.com,yunqiang.wu@hand-china.com ; fi - export root_url=http://`cat CNAME` - export test_passed_rate=$(printf &quot;%.2f&quot; `cat dist/test-report/testResultData.json | jq &#x27;100*.numPassedTests/.numTotalTests&#x27;`)% - bash ./tool/emailnotice.sh $MAIL_TO &#x27;前端自动化测试&#x27; `echo -e &quot; 测试分支： $&#123;CI_COMMIT_REF_NAME&#125; \\r\\n 提交人：$&#123;GITLAB_USER_NAME&#125; \\r\\n 测试通过率：$&#123;test_passed_rate&#125; \\r\\n 触发来源：$&#123;CI_PIPELINE_SOURCE&#125; \\r\\n 测试环境：mockApi环境 \\r\\n\\r\\n预览地址： $&#123;root_url&#125;/index.html \\r\\n 自动化测试报告：$&#123;root_url&#125;/test-report/reporter.html \\r\\n 测试覆盖率报告： $&#123;root_url&#125;/coverage/lcov-report/index.html \\r\\n&quot;` stage: email only: - master artifacts: paths: - dist 注意事项 react 开发是如果用了css modules的技术开发时，会把 class 名换掉 ，测试框架就无法通过 css selector 找到并操作 Dom元素，在开发时，可以为主要控制的dom节点给id，data-custom 自定义属性，比如用户名输入框、登录按钮， 我这里的介绍的自动化测试，只是测试系统的功能交互是否能正常，如果需要靠自动化测试来判断UI界面的样式对比是符合要求，可能还是要靠人力测试，不过测试的目的保证系统功能成正常使用不出BUG。 参考 如何进行前端自动化测试？ - 知乎 ANT DESIGN PRO 中的 UI 测试","tags":[{"name":"gitab-ci","slug":"gitab-ci","permalink":"http://blog.jajabjbj.top/tags/gitab-ci/"}]},{"title":"webpack引入第三方库方案总结","date":"2018-05-08T00:00:00.000Z","path":"2018/05/08/2018-05-21-1/","text":"webpack引入第三方库方案总结 在使用webpack打包项目时，最好尽量使用import的方式引入第三方库，但有些情况又必须使用其他方式引入第三方库… 要项目上必须要用一个 jQuery 插件形式的库而引入这个库之前必须要引入jQuery，因为插件里面可能会出现这样的代码 123456789(function() &#123;var jQuery = window.jQuery,\\\\ ...\\\\ ...if (!jQuery) throw &#x27;MathQuill requires jQuery 1.4.3+ to be loaded first&#x27;;\\\\ ...\\\\ ...\\\\ ...&#125;)(); 所以需要在webpack构建的项目中引入 第三方 js库，一般情况下引入第三方库有以下几种方式 直接引入直接引入的关键在于输出的配置，这里以var为例，如下： 123456789101112131415161718 output : &#123; filename : &#x27;[name].js&#x27;, // devServer不可配置为绝对路径 //publicPath: &quot;http://localhost:8080/dist/&quot;, publicPath: &quot;/dist/&quot;, path : build, // umd包含了对amd、commonjs、var等多种规范的支持 // 关键在于这里 libraryTarget : &#x27;var&#x27; &#125;, // 其他配置略 resolve: &#123; //extensions: [&#x27;&#x27;, &#x27;.js&#x27;, &#x27;.es6&#x27;, &#x27;.vue&#x27;], alias: &#123; // 也可以不写 jquery: &#x27;jquery/dist/jquery.min.js&#x27;, &#125;&#125; 这样，在编译代码时，webpack会自动将jQuery打进代码，现在就可以引入代码了 12345// 可以直接引入jqueryimport $ from &#x27;jquery&#x27;// 因为是commonjs规范，所以会按顺序加载，引用成功，如果是output为amd，则必须在requirejs中配置shim，否则失败import &#x27;jquery-ui&#x27; 2. ProvidePlugin[难以引入插件]在webpack中添加插件ProvidePlugin 1234567plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;), ]// $函数会自动添加到当前模块的上下文，无需显示声明 问题是依旧没有全局的$函数，所以导入插件依旧会失败，并且如果有eslint这样的preLoads，调用语句也难以通过语法校验(因为没有声明$就直接使用)，仅这一点，对于我这样的代码处女座就难以接受。 3. expose-loader[推荐使用]不需要任何其他的插件配合，只要将下面的代码添加到所有的loader之前 1234&#123; test: require.resolve(&#x27;jquery&#x27;), loader: &#x27;expose?jQuery!expose?$&#x27;&#125; 引用时改为如下方式 12import $ from &#x27;expose?$!jquery&#x27;import &#x27;jquery-ui&#x27; //插件可用 imports-loader、script-loader同样可达到此效果，配置与功能都非常相似，在此不一一说明。 4. 包装jquery[推荐使用]此方法只依赖于自己，完全不需要任何其他插件与加载器，创建jquery的包装对象jquery-vendor.js 1234import $ from &#x27;jquery&#x27;window.$ = $window.jQuery = $export default $ 以后引用jquery时指向jquery-vendor.js 123import $ from &#x27;../assets/jquery-vendor.js&#x27;import &#x27;jquery-ui&#x27;// 此时UI的方法全部可用，如果需要引用bootstrap，可参照此方法 为了调用方便，可在webpack配置文件中创建jquery-vendor.js的别名 123alias: &#123; jquery : &#x27;src/assets/jquery-vendor.js&#x27; // 将其指向jquery-vendor.js所在位置&#125; 2. 第三方库需要通过 类似requirejs机制 异步加载其他依赖库1234567891011121314151617181920212223242526272829// 这是 MathJax 数学表达式解析库 加载扩展的一段代码// 该库需要加载 extensions 而且是通过在页面插入script的方式加载的loader: &#123; JS: function (k, m) &#123; var j = this.fileName(k); var i = document.createElement(&quot;script&quot;); var l = a.Callback([&quot;loadTimeout&quot;, this, k]); this.loading[k] = &#123; callback: m, timeout: setTimeout(l, this.timeout), status: this.STATUS.OK, script: i &#125;; this.loading[k].message = a.Message.File(j); i.onerror = l; i.type = &quot;text/javascript&quot;; i.src = k + this.fileRev(j); this.head.appendChild(i) &#125;, CSS: function (j, l) &#123; var i = this.fileName(j); var k = document.createElement(&quot;link&quot;); k.rel = &quot;stylesheet&quot;; k.type = &quot;text/css&quot;; k.href = j + this.fileRev(i); this.loading[j] = &#123;callback: l, message: a.Message.File(i), status: this.STATUS.OK&#125;; this.head.appendChild(k); this.timer.create.call(this, [this.timer.file, j], k) &#125;&#125;, 遇到这种情况，就不能用常规的方法引入第三方依赖，以上的方法都不适用，因为在编译期间不会再报错 但是在运行期间会报一个js文件加载404的错误。因为这是在运行之后通过注入script标签 加载插件 。而在编译时webpack不会检测到这种异步加载逻辑 并导入。 我的解决方案： 要使能够通过异步加载 ，必须保证 映入的库 和他的依赖文件 相对文章不变 ，整体放到 编译后的目录。以引入 MathJax 数学表达式解析库为例 由于MathJax 的加载扩展（MathMenu）是用到 类似 requirejs的异步加载机制 ，所以需要引入mathquill 只能通过 script 标签引入，不能通过 import 引入 mathquill 修改文件如下： 1. webpack.config.js:12// 在编译打包时 把 /src/lib/下的 js文件复制到 www(编译输出目录)/lib 目录new CopyWebpackPlugin([ &#123;from: &#x27;./src/lib&#x27;, to: &#x27;lib&#x27;&#125;]), 2. index.html:123456&lt;script src=&quot;./lib/polyvplayer/polyvplayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./lib/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./lib/cat_mathjax/dist/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./lib/cat_mathquill_build/mathquill.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/cat_mathquill_build/mathquill.css&quot;&gt; 3. 添加文件夹：&#x2F;src&#x2F;lib12/src/lib/jquery/ /src/lib/mathjax/","tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.jajabjbj.top/tags/webpack/"}]}]